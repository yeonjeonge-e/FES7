<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>피보나치 수열</title>
</head>

<body>
  <script>
    // 피보나치 수열
    // 1, 1, 2, 3, 5, 8, 13 ~~~
    // 1+1=2, 2+3=5, 3+8=13
    // 특정 n번째의 숫자를 구하는 경우가 피보나치 수열

    function fn(n) {
      if (n === 1 || n === 2) {
        return 1
      } else {
        return fn(n - 1) + fn(n - 2)
      }
    }
    // 이건 실행 시킨 후 개발자 도구-콘솔 창에서 확인하기


    // 설명
    // fn(6)
    // fn(5) + fn(4)
    // fn(4)+fn(3) + fn(3)+fn(2)
    // fn(3)+fn(2)+fn(2)+fn(1) + fn(2)+fn(1)+fn(1)+1
    // fn(2)+fn(1)+1+1 + 1+1+1+1
    // 1+1+1+1 + 1+1+1+1
    // 8





    // 메모이제이션 적용
    const memo = [];

    // function fnMemo(n) {
    //   if (n === 1 || n === 2) {
    //     memo[n] = 1;
    //     return 1
    //   } else if (memo[n] !== undefined) {
    //     return memo[n]
    //     // memo[n] 인덱스에 접근하는데 그 값이 언디파인드가 아니다 라는 것은 안에 값이 저장이 되어있다는것 그럼 n번째에 값을 저장해줌
    //   } else {
    //     memo[n] = fnMemo(n - 1) + fnMemo(n - 2);
    //     return memo[n]
    //   }
    // }

    // 위의 if ~ if-else ~ else문 대신 아래처럼 널리쉬 라는 걸 사용할 수도 있음

    function fnMemo(n) {
      if (n === 1 || n === 2) {
        memo[n] = 1;
        return 1
      } else {
        return memo[n] ?? (memo[n] = fnMemo(n - 1) + fnMemo(n - 2));
      }
    }

    // 설명
    // fnMemo(6)
      
    // memo[6] = fnMemo(5) + fnMemo(4);
    // memo ==> [undefined, 1, 1, 2, 3, 5, 8];
  </script>
</body>

</html>

<!-- 메모리 관리와 실행 속도와 분리해서 보고,  메모이제이션은 실행 속도 측을 개선할 때 사용한다는 거죠? - 정답 -->